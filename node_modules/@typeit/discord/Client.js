"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const discord_js_1 = require("discord.js");
const Glob = require("glob");
const _1 = require(".");
class Client extends discord_js_1.Client {
    /**
     * Create your bot
     * @param options { silent: boolean, loadClasses: LoadClass[] }
     */
    constructor(options) {
        super(options);
        this._silent = (options === null || options === void 0 ? void 0 : options.silent) !== undefined || false;
        this._loadClasses = (options === null || options === void 0 ? void 0 : options.classes) || [];
        Client._variablesChar = (options === null || options === void 0 ? void 0 : options.variablesChar) || ":";
        Client._variablesExpression = new RegExp(`\\s{1,}${Client._variablesChar}\\w*`, "g");
    }
    static get variablesChar() {
        return this._variablesChar;
    }
    static get variablesExpression() {
        return this._variablesExpression;
    }
    get silent() {
        return this._silent;
    }
    set silent(value) {
        this._silent = value;
    }
    /**
     * Get the details about the created commands of your app (@Command)
     */
    static getCommands() {
        return _1.MetadataStorage.instance.commands.map((c) => c.commandInfos);
    }
    /**
     * Get the details about the created events of your app (@On)
     */
    static getEvent() {
        return _1.MetadataStorage.instance.events.map((event) => {
            return {
                event: event.event,
                once: event.once,
                linkedInstance: event.linkedDiscord
            };
        });
    }
    /**
     * Get the details about the created discords of your app (@Discord)
     */
    static getDiscords() {
        return _1.MetadataStorage.instance.discords.map((d) => d.discordInfos);
    }
    /**
     * Get the details about the created commandsNotFound of your app (@CommandNotFound)
     */
    static getCommandsNotFound() {
        return _1.MetadataStorage.instance.commandsNotFound.map((c) => {
            return {
                infos: c.infos,
                prefix: c.linkedDiscord.prefix,
                description: c.infos.description
            };
        });
    }
    /**
     * Start your bot
     * @param token The bot token
     * @param loadClasses A list of glob path or classes
     */
    login(token, ...loadClasses) {
        if (!this.silent) {
            console.log("@typeit/discord: @Commands will be soon deprecated");
            console.log("@typeit/discord: you should update to v5 that includes the new Discord Slash commands");
            console.log("@typeit/discord: More informations: https://owencalvin.github.io/discord.ts/");
        }
        if (loadClasses.length > 0) {
            this._loadClasses = loadClasses;
        }
        this.build();
        _1.MetadataStorage.instance.events.map((event) => {
            if (!this.silent) {
                let eventName = event.event;
                console.log(`${eventName}: ${event.classRef.name}.${event.key}`);
            }
        });
        const usedEvents = (_1.MetadataStorage.instance.events
            .reduce((prev, event, index) => {
            const found = _1.MetadataStorage.instance.events.find((event2) => event.event === event2.event);
            const foundIndex = _1.MetadataStorage.instance.events.indexOf(found);
            if (foundIndex === index || found.once !== event.once) {
                prev.push(event);
            }
            return prev;
        }, []));
        usedEvents.map(async (on) => {
            if (on.once) {
                this.once(on.event, _1.MetadataStorage.instance.trigger(on.event, this, true));
            }
            else {
                this.on(on.event, _1.MetadataStorage.instance.trigger(on.event, this));
            }
        });
        return super.login(token);
    }
    /**
     * Manually build the app
     */
    async build() {
        this.loadClasses();
        await _1.MetadataStorage.instance.build();
    }
    /**
     * Manually trigger an event (used for tests)
     * @param event The event
     * @param params Params to inject
     * @param once Trigger an once event
     */
    trigger(event, params, once = false) {
        return _1.MetadataStorage.instance.trigger(event, this, once)(params);
    }
    loadClasses() {
        if (this._loadClasses) {
            this._loadClasses.map((file) => {
                if (typeof file === "string") {
                    const files = Glob.sync(file);
                    files.map((file) => {
                        require(file);
                    });
                }
            });
        }
    }
}
exports.Client = Client;
//# sourceMappingURL=Client.js.map